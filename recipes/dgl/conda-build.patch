diff --git a/CMakeLists.txt b/CMakeLists.txt
index 097a1839..dcc4702d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -36,8 +36,45 @@ dgl_option(USE_S3 "Build with S3 support" OFF)
 dgl_option(USE_HDFS "Build with HDFS support" OFF) # Set env HADOOP_HDFS_HOME if needed
 dgl_option(REBUILD_LIBXSMM "Clean LIBXSMM build cache at every build" OFF) # Set env HADOOP_HDFS_HOME if needed
 dgl_option(USE_EPOLL "Build with epoll for socket communicator" OFF)
+dgl_option(USE_TENSORPIPE "Build with tensorpipe (only impacts Linux)" ON)
 dgl_option(TP_BUILD_LIBUV "Build libuv together with tensorpipe (only impacts Linux)" ON)
 
+# options to force use external libraries
+dgl_option(USE_ALL_EXTERNAL_LIBS "Force to use external third party libraries rather than those vendored in ./third_party" OFF)
+dgl_option(USE_EXTERNAL_THRUST "Force to use external thrust" OFF)
+dgl_option(USE_EXTERNAL_DLPACK "Force to use external dlpack" OFF)
+dgl_option(USE_EXTERNAL_DMLC "Force to use external dmlc-core" OFF)
+dgl_option(USE_EXTERNAL_METIS "Force to use external metis" OFF)
+dgl_option(USE_EXTERNAL_PHMAP "Force to use external parallel-hashmap" OFF)
+dgl_option(USE_EXTERNAL_XBYAK "Force to use external xbyak" OFF)
+dgl_option(USE_EXTERNAL_NANOFLANN "Force to use external nanoflann" OFF)
+
+
+dgl_option(USE_CONDA_INCLUDE, "Add conda include path to include directories" OFF)
+
+
+if(USE_ALL_EXTERNAL_LIBS)
+  message(STATUS "Use all external libraries")
+  option(USE_EXTERNAL_THRUST ON)
+  option(USE_EXTERNAL_DLPACK ON)
+  option(USE_EXTERNAL_DMLC ON)
+  option(USE_EXTERNAL_METIS ON)
+  option(USE_EXTERNAL_PHMAP ON)
+  option(USE_EXTERNAL_XBYAK ON)
+  option(USE_EXTERNAL_NANOFLANN ON)
+endif()
+
+
+if(USE_ALL_EXTERNAL_LIBS OR USE_EXTERNAL_THRUST OR USE_EXTERNAL_DLPACK OR USE_EXTERNAL_DMLC OR USE_EXTERNAL_METIS OR USE_EXTERNAL_PHMAP OR USE_EXTERNAL_XBYAK OR USE_EXTERNAL_NANOFLANN)
+  message(STATUS "Use external libraries")
+  set(USE_EXTERNAL_LIBS ON)
+else()
+  set(USE_EXTERNAL_LIBS OFF)
+endif()
+
+set(CMAKE_MODULE_PATH  ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/modules/")
+
+
 # Set debug compile option for gdb, only happens when -DCMAKE_BUILD_TYPE=DEBUG
 if (NOT MSVC)
   set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DDEBUG -O0 -g3 -ggdb")
@@ -47,16 +84,19 @@ if(USE_CUDA)
   message(STATUS "Build with CUDA support")
   project(dgl C CXX)
   include(cmake/modules/CUDA.cmake)
-  if ((CUDA_VERSION_MAJOR LESS 11) OR
-      ((CUDA_VERSION_MAJOR EQUAL 11) AND (CUDA_VERSION_MINOR EQUAL 0)))
-    # For cuda<11, use external CUB/Thrust library because CUB is not part of CUDA.
-    # For cuda==11.0, use external CUB/Thrust library because there is a bug in the
-    #   official CUB library which causes invalid device ordinal error for DGL. The bug
-    #   is fixed by https://github.com/NVIDIA/cub/commit/9143e47e048641aa0e6ddfd645bcd54ff1059939
-    #   in 11.1.
-    message(STATUS "Detected CUDA of version ${CUDA_VERSION}. Use external CUB/Thrust library.")
+
+  message(STATUS "Detected CUDA of version ${CUDA_VERSION}. Use external CUB/Thrust library.")
+    
+  if (USE_EXTERNAL_THRUST)
+    find_package(Thrust REQUIRED CONFIG)
+    if (NOT THRUST_FOUND)
+      message(FATAL_ERROR "Thrust not found")
+    endif()
+    message(STATUS "Found Thrust ${THRUST_VERSION} with include directory ${_THRUST_INCLUDE_DIR}" )
+    cuda_include_directories(BEFORE "${_THRUST_INCLUDE_DIR}")
+  else()
     cuda_include_directories(BEFORE "${CMAKE_SOURCE_DIR}/third_party/thrust")
-    cuda_include_directories(BEFORE "${CMAKE_SOURCE_DIR}/third_party/cub")
+    cuda_include_directories(BEFORE "${CMAKE_SOURCE_DIR}/third_party/thrust/dependencies/cub")
   endif()
 endif(USE_CUDA)
 
@@ -94,8 +134,8 @@ else(MSVC)
   include(CheckCXXCompilerFlag)
   # tensorpipe's dependencies require C++14
   check_cxx_compiler_flag("-std=c++14"    SUPPORT_CXX14)
-  set(CMAKE_C_FLAGS "-O2 -Wall -fPIC ${CMAKE_C_FLAGS}")
-  set(CMAKE_CXX_FLAGS "-O2 -Wall -fPIC -std=c++14 ${CMAKE_CXX_FLAGS}")
+  set(CMAKE_C_FLAGS "-O2  -fPIC ${CMAKE_C_FLAGS}")
+  set(CMAKE_CXX_FLAGS "-O2 -fPIC -std=c++14 ${CMAKE_CXX_FLAGS}")
   if(NOT APPLE)
     set(CMAKE_SHARED_LINKER_FLAGS "-Wl,--warn-common ${CMAKE_SHARED_LINKER_FLAGS}")
   endif(NOT APPLE)
@@ -206,65 +246,195 @@ endif(USE_CUDA)
 
 set_property(TARGET dgl PROPERTY CXX_STANDARD 14)
 
-# include directories
+
+
+# include directories that we need
 target_include_directories(dgl PRIVATE "include")
-target_include_directories(dgl PRIVATE "third_party/dlpack/include")
-target_include_directories(dgl PRIVATE "third_party/dmlc-core/include")
-target_include_directories(dgl PRIVATE "third_party/phmap/")
-target_include_directories(dgl PRIVATE "third_party/xbyak/")
-target_include_directories(dgl PRIVATE "third_party/METIS/include/")
 target_include_directories(dgl PRIVATE "tensoradapter/include")
-target_include_directories(dgl PRIVATE "third_party/nanoflann/include")
-target_include_directories(dgl PRIVATE "third_party/libxsmm/include")
 
 
-# For serialization
-if (USE_HDFS)
-  option(DMLC_HDFS_SHARED "dgl has to build with dynamic hdfs library" ON)
+# check for conda includes
+if("$ENV{CONDA_BUILD}" STREQUAL "1")
+  set(in_conda_build True)
+  message(STATUS "Conda build environment detected")
+elseif(DEFINED ENV{CONDA_PREFIX})
+  set(in_conda_prefix True)
+  message(STATUS "Conda environment detected: $ENV{CONDA_PREFIX}")
 endif()
-add_subdirectory("third_party/dmlc-core")
-list(APPEND DGL_LINKER_LIBS dmlc)
-set(GOOGLE_TEST 0) # Turn off dmlc-core test
 
-# Compile METIS
-if(NOT MSVC)
-  set(GKLIB_PATH "${CMAKE_CURRENT_SOURCE_DIR}/third_party/METIS/GKlib")
-  include(${GKLIB_PATH}/GKlibSystem.cmake)
-  include_directories(${GKLIB_PATH})
-  include_directories("third_party/METIS/include/")
-  add_subdirectory("third_party/METIS/libmetis/")
-  list(APPEND DGL_LINKER_LIBS metis)
-endif(NOT MSVC)
+if (USE_CONDA_INCLUDES)
+  if(in_conda_build)
+    message(STATUS "Using Conda build environment includes: $ENV{PREFIX}")
+    target_include_directories(dgl PRIVATE "$ENV{PREFIX}/include" "$ENV{BUILD_PREFIX}/include")
+  elseif(in_conda_prefix)
+    message(STATUS "Using Conda environment includes: $ENV{CONDA_PREFIX}")
+    target_include_directories(dgl PRIVATE "$ENV{CONDA_PREFIX}/include")
+  else()
+    message(FATAL_ERROR "Conda environment not detected")
+  endif()
+endif()
 
-# Compile LIBXSMM
-if((NOT MSVC) AND USE_LIBXSMM)
-  if(REBUILD_LIBXSMM)
-    add_custom_target(libxsmm COMMAND make realclean COMMAND make -j BLAS=0
-                      WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/third_party/libxsmm
-                      )
-  else(REBUILD_LIBXSMM)
-    add_custom_target(libxsmm COMMAND make -j BLAS=0
-                      WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/third_party/libxsmm
-                      )
-  endif(REBUILD_LIBXSMM)
-  add_dependencies(dgl libxsmm)
-  list(APPEND DGL_LINKER_LIBS -L${CMAKE_SOURCE_DIR}/third_party/libxsmm/lib/ xsmm)
-endif((NOT MSVC) AND USE_LIBXSMM)
+# dlpack is just an include
+if (USE_EXTERNAL_DLPACK)
+  find_package(DLPACK REQUIRED)
+  if (DLPACK_FOUND)
+    target_include_directories(dgl PRIVATE ${DLPACK_INCLUDE_DIRS})
+  else()
+    message(FATAL_ERROR "dlpack not found")
+  endif()
+else()
+  target_include_directories(dgl PRIVATE "third_party/dlpack/include")
+endif()
 
-if(NOT MSVC)
-  # Only build tensorpipe on linux
-  string(REPLACE "-pedantic" "" CMAKE_C_FLAGS ${CMAKE_C_FLAGS})
-  set(TP_STATIC_OR_SHARED STATIC)
-  add_subdirectory(third_party/tensorpipe)
-  list(APPEND DGL_LINKER_LIBS tensorpipe)
-  target_include_directories(dgl PRIVATE third_party/tensorpipe)
-endif(NOT MSVC)
+
+# dmlc-core
+if (USE_EXTERNAL_DMLC)
+  if (USE_HDFS)
+    message(FATAL_ERROR "external lib DMLC does not support HDFS")
+  endif()
+  find_package(DMLC REQUIRED)
+  if(DMLC_FOUND)
+    target_include_directories(dgl PRIVATE ${DMLC_INCLUDE_DIR})
+    target_link_libraries(dgl ${DMLC_LIBRARY})
+  else()
+    message(FATAL_ERROR "dmlc not found")
+  endif()
+else()
+  target_include_directories(dgl PRIVATE "third_party/dmlc-core/include")
+  # For serialization
+  if (USE_HDFS)
+    option(DMLC_HDFS_SHARED "dgl has to build with dynamic hdfs library" ON)
+  endif()
+  add_subdirectory("third_party/dmlc-core")
+  list(APPEND DGL_LINKER_LIBS dmlc)
+  set(GOOGLE_TEST 0) # Turn off dmlc-core test
+endif()
+
+
+# metis and gklib
+if (USE_EXTERNAL_METIS)
+  message(FATAL_ERROR "external metis not supported yet")
+  find_package(METIS REQUIRED)
+  if (METIS_FOUND)
+    target_include_directories(dgl SYSTEM PUBLIC ${METIS_INCLUDE_DIRS})
+    target_link_libraries(dgl ${METIS_LIBRARY})
+  else()
+    message(FATAL_ERROR "metis not found")
+  endif()
+
+  # find_package(GKLIB REQUIRED)
+  # if (GKLIB_FOUND)
+  # target_include_directories(dgl SYSTEM PUBLIC ${GKLIB_INCLUDE_DIRS})
+  # else()
+  #   message(FATAL_ERROR "glkib not found")
+  # endif() << FINISH THIS 
+
+else()
+  target_include_directories(dgl PRIVATE "third_party/METIS/include/")
+
+  # Compile METIS
+  if(NOT MSVC)
+    set(GKLIB_PATH "${CMAKE_CURRENT_SOURCE_DIR}/third_party/METIS/GKlib")
+    include(${GKLIB_PATH}/GKlibSystem.cmake)
+    include_directories(${GKLIB_PATH})
+    include_directories("third_party/METIS/include/")
+    add_subdirectory("third_party/METIS/libmetis/")
+    list(APPEND DGL_LINKER_LIBS metis)
+  endif(NOT MSVC)
+
+endif()
+
+
+# phmap
+if (USE_EXTERNAL_PHMAP)
+  find_package(PHMAP REQUIRED)
+  if (PHMAP_FOUND)
+    target_include_directories(dgl SYSTEM PUBLIC ${PHMAP_INCLUDE_DIR})
+  else()
+    message(FATAL_ERROR "phmap not found")
+  endif()
+else()
+  target_include_directories(dgl PRIVATE "third_party/phmap/")
+endif()
+
+
+# xbyak 
+if (USE_EXTERNAL_XBYAK)
+  find_package(XBYAK REQUIRED)
+  if (XBYAK_FOUND)
+    target_include_directories(dgl SYSTEM PUBLIC ${XBYAK_INCLUDE_DIR})
+  else()
+    message(FATAL_ERROR "xbyak not found")
+  endif()
+else()
+  target_include_directories(dgl PRIVATE "third_party/xbyak/")
+endif()
+
+# nanoflann
+if (USE_EXTERNAL_NANOFLANN)
+  find_package(NANOFLANN REQUIRED)
+  if (NANOFLANN_FOUND)
+    target_include_directories(dgl SYSTEM PUBLIC ${NANOFLANN_INCLUDE_DIR})
+  else()
+    message(FATAL_ERROR "nanoflann not found")
+  endif()
+else()
+  target_include_directories(dgl PRIVATE "third_party/nanoflann/include")
+endif()
+
+
+
+
+if (USE_LIBXSMM)
+
+  target_include_directories(dgl PRIVATE "third_party/libxsmm/include")
+  # Compile LIBXSMM
+  if(MSVC)
+    message(WARNING "LIBXSMM is not supported with MSVC, ignoring")
+  else()
+    if(REBUILD_LIBXSMM)
+      add_custom_target(libxsmm COMMAND make realclean COMMAND make -j BLAS=0
+                        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/third_party/libxsmm
+                        )
+    else(REBUILD_LIBXSMM)
+      add_custom_target(libxsmm COMMAND make -j BLAS=0
+                        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/third_party/libxsmm
+                        )
+    endif(REBUILD_LIBXSMM)
+    add_dependencies(dgl libxsmm)
+    list(APPEND DGL_LINKER_LIBS -L${CMAKE_SOURCE_DIR}/third_party/libxsmm/lib/ xsmm)
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-error=deprecated-declarations")
+
+  endif()
+endif()
+
+
+if (USE_TENSORPIPE)
+  # if (USE_ALL_EXTERNAL_LIBS)
+  #   message(FATAL_ERROR "Cannot build with external libs and tensorpipe")
+  # endif()
+  if(MSVC)
+    message(WARNING "MSVC does not support tensorpipe, disabling it")
+  else()
+    # Only build tensorpipe on linux
+    string(REPLACE "-pedantic" "" CMAKE_C_FLAGS ${CMAKE_C_FLAGS})
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-sign-compare")
+    set(TP_STATIC_OR_SHARED STATIC)
+    add_subdirectory(third_party/tensorpipe)
+    list(APPEND DGL_LINKER_LIBS tensorpipe)
+    target_include_directories(dgl PRIVATE third_party/tensorpipe)
+  endif()
+
+endif()
 
 # Compile TVM Runtime and Featgraph
 # (NOTE) We compile a dynamic library called featgraph_runtime, which the DGL library links to.
 # Kernels are packed in a separate dynamic library called featgraph_kernels, which DGL
 # will load during runtime.
 if(USE_TVM)
+  if (USE_EXTERNAL_LIBS)
+    message(FATAL_ERROR "using TVM with external libraries is not supported" )
+  endif()
   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DUSE_TVM")
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DUSE_TVM")
   target_include_directories(dgl PRIVATE "featgraph/include")
@@ -292,6 +462,9 @@ endif(MSVC)
 # of the wrong version when I build everything in the same CMake process.  As
 # a result, I (BarclayII) am launching an individual CMake build for every PyTorch version.
 if(BUILD_TORCH)
+  if (USE_EXTERNAL_LIBS)
+    message(FATAL_ERROR "Cannot build with external libs and pytorch backend")
+  endif()
   file(TO_NATIVE_PATH ${CMAKE_CURRENT_BINARY_DIR} BINDIR)
   file(TO_NATIVE_PATH ${CMAKE_COMMAND} CMAKE_CMD)
   if(MSVC)
@@ -320,11 +493,16 @@ if(BUILD_TORCH)
   add_dependencies(dgl tensoradapter_pytorch)
 endif(BUILD_TORCH)
 
+
+
 # Installation rules
 install(TARGETS dgl DESTINATION lib${LIB_SUFFIX})
 
 # Testing
 if(BUILD_CPP_TEST)
+  if (USE_EXTERNAL_LIBS)
+    message(FATAL_ERROR "Cannot build tests with external libs")
+  endif()
   message(STATUS "Build with unittest")
   add_subdirectory(./third_party/googletest)
   enable_testing()
diff --git a/cmake/modules/FindDLPACK.cmake b/cmake/modules/FindDLPACK.cmake
new file mode 100644
index 00000000..779e7146
--- /dev/null
+++ b/cmake/modules/FindDLPACK.cmake
@@ -0,0 +1,41 @@
+# Define a CMake module to find dlpack header using find_package
+
+# Usage: find_package(DLPack [VERSION version] [REQUIRED] [QUIET])
+#
+# Searches for the dlpack header file and sets the variable
+# `DLPACK_FOUND` to `TRUE` if the header file is found,
+# and sets the variable `DLPACK_INCLUDE_DIRS` to the include directories
+# containing the header file.
+#
+# Example usage:
+#   find_package(DLPACK REQUIRED)
+# Define user options
+
+if(NOT DLPACK_INCLUDE_DIR)
+  message(STATUS "DLPACK_INCLUDE_DIR not defined, searching for dlpack header")  
+  find_path(DLPACK_INCLUDE_DIR dlpack/dlpack.h
+    HINTS "$ENV{DLPACK}/include" "$ENV{CONDA_PREFIX}/include" "$ENV{BUILD_PREFIX}/include"
+    PATH_SUFFIXES include
+    DOC "Directory where the DLPACK header files are located"
+  )
+endif()
+
+# Find dlpack header
+find_path(DLPACK_INCLUDE_DIRS
+    NAMES dlpack/dlpack.h
+    PATH_SUFFIXES include
+)
+
+# Check if dlpack header is found
+if(DLPACK_INCLUDE_DIR)
+    message(STATUS "dlpack found")
+    set(DLPACK_FOUND TRUE)
+else()
+    set(DLPACK_FOUND FALSE)
+endif()
+
+# Standard package handling
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(DLPACK REQUIRED_VARS DLPACK_INCLUDE_DIR)
+
+mark_as_advanced(DLPACK_INCLUDE_DIR)
diff --git a/cmake/modules/FindDMLC.cmake b/cmake/modules/FindDMLC.cmake
new file mode 100644
index 00000000..45e013f2
--- /dev/null
+++ b/cmake/modules/FindDMLC.cmake
@@ -0,0 +1,55 @@
+# Define a CMake module to find dlpack header using find_package
+
+# Usage: find_package(DLPack [VERSION version] [REQUIRED] [QUIET])
+#
+# Searches for the dlpack header file and sets the variable
+# `DLPACK_FOUND` to `TRUE` if the header file is found,
+# and sets the variable `DLPACK_INCLUDE_DIRS` to the include directories
+# containing the header file.
+#
+# Example usage:
+#   find_package(DLPACK REQUIRED)
+# Define user options
+
+if(NOT DMLC_INCLUDE_DIR)
+  message(STATUS "DMLC_INCLUDE_DIR not defined, searching for dmlc header")  
+  find_path(DMLC_INCLUDE_DIR dmlc/base.h
+    HINTS "$ENV{DMLC}/include" "$ENV{CONDA_PREFIX}/include" "$ENV{BUILD_PREFIX}/include"
+    PATH_SUFFIXES include
+    DOC "Directory where the DMLC header files are located"
+  )
+endif()
+
+# Find dlpack header
+find_path(DMLC_INCLUDE_DIR
+    NAMES dmlc/base.h
+    PATH_SUFFIXES include
+)
+
+if(DMLC_LIBRARY)
+  set(DMLC_LIBRARY ${DMLC_LIBRARY})
+endif()
+if(NOT DMLC_LIBRARY)
+  message(STATUS "DMLC_LIBRARY not defined, searching for dmlc library")  
+  find_library(DMLC_LIBRARY
+    NAMES dmlc 
+    HINTS $ENV{CONDA_PREFIX}/lib
+    PATH_SUFFIXES lib
+    DOC "Directory where the DMLC library is located"
+  )
+endif()
+
+
+# Check if dlpack header is found
+if(DMLC_INCLUDE_DIR AND DMLC_LIBRARY)
+    message(STATUS "dmlc found include: ${DMLC_INCLUDE_DIR} lib: ${DMLC_LIBRARY}")
+    set(DMLC_FOUND TRUE)
+else()
+    set(DMLC_FOUND FALSE)
+endif()
+
+# Standard package handling
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(DMLC REQUIRED_VARS DLPACK_INCLUDE_DIR)
+
+mark_as_advanced(DMLC_INCLUDE_DIR DMLC_LIBRARY)
diff --git a/cmake/modules/FindMETIS.cmake b/cmake/modules/FindMETIS.cmake
new file mode 100644
index 00000000..3b6f230a
--- /dev/null
+++ b/cmake/modules/FindMETIS.cmake
@@ -0,0 +1,131 @@
+# - Try to find METIS
+# Once done this will define
+#
+#  METIS_FOUND        - system has METIS
+#  METIS_INCLUDE_DIRS - include directories for METIS
+#  METIS_LIBRARIES    - libraries for METIS
+#
+# Variables used by this module. They can change the default behaviour and
+# need to be set before calling find_package:
+#
+#  METIS_DIR          - Prefix directory of the METIS installation
+#  METIS_INCLUDE_DIR  - Include directory of the METIS installation
+#                       (set only if different from ${METIS_DIR}/include)
+#  METIS_LIB_DIR      - Library directory of the METIS installation
+#                       (set only if different from ${METIS_DIR}/lib)
+#  METIS_TEST_RUNS    - Skip tests building and running a test
+#                       executable linked against METIS libraries
+#  METIS_LIB_SUFFIX   - Also search for non-standard library names with the
+#                       given suffix appended
+#
+# NOTE: This file was modified from a ParMETIS detection script 
+
+#=============================================================================
+# Copyright (C) 2015 Jack Poulson. All rights reserved.
+#
+# Copyright (C) 2010-2012 Garth N. Wells, Anders Logg, Johannes Ring
+# and Florian Rathgeber. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#=============================================================================
+
+if(NOT METIS_INCLUDE_DIR)
+  find_path(METIS_INCLUDE_DIR metis.h
+    HINTS ${METIS_INCLUDE_DIR} ENV METIS_INCLUDE_DIR ${METIS_DIR} ENV METIS_DIR
+    PATH_SUFFIXES include
+    DOC "Directory where the METIS header files are located"
+  )
+endif()
+
+if(METIS_LIBRARIES)
+  set(METIS_LIBRARY ${METIS_LIBRARIES})
+endif()
+if(NOT METIS_LIBRARY)
+  find_library(METIS_LIBRARY
+    NAMES metis metis${METIS_LIB_SUFFIX}
+    HINTS ${METIS_LIB_DIR} ENV METIS_LIB_DIR ${METIS_DIR} ENV METIS_DIR
+    PATH_SUFFIXES lib
+    DOC "Directory where the METIS library is located"
+  )
+endif()
+
+
+
+# Get METIS version
+if(NOT METIS_VERSION_STRING AND METIS_INCLUDE_DIR AND EXISTS "${METIS_INCLUDE_DIR}/metis.h")
+  set(version_pattern "^#define[\t ]+METIS_(MAJOR|MINOR)_VERSION[\t ]+([0-9\\.]+)$")
+  file(STRINGS "${METIS_INCLUDE_DIR}/metis.h" metis_version REGEX ${version_pattern})
+
+  foreach(match ${metis_version})
+    if(METIS_VERSION_STRING)
+      set(METIS_VERSION_STRING "${METIS_VERSION_STRING}.")
+    endif()
+    string(REGEX REPLACE ${version_pattern} "${METIS_VERSION_STRING}\\2" METIS_VERSION_STRING ${match})
+    set(METIS_VERSION_${CMAKE_MATCH_1} ${CMAKE_MATCH_2})
+  endforeach()
+  unset(metis_version)
+  unset(version_pattern)
+endif()
+
+# Try compiling and running test program
+if(METIS_INCLUDE_DIR AND METIS_LIBRARY)
+
+  # Set flags for building test program
+  set(CMAKE_REQUIRED_INCLUDES ${METIS_INCLUDE_DIR})
+  set(CMAKE_REQUIRED_LIBRARIES ${METIS_LIBRARY})
+
+  # Build and run test program
+  include(CheckCSourceRuns)
+  check_c_source_runs("
+#define METIS_EXPORT
+#include \"metis.h\"
+int main( int argc, char* argv[] )
+{
+  // FIXME: Find a simple but sensible test for METIS
+  return 0;
+}
+" METIS_TEST_RUNS)
+
+  unset(CMAKE_REQUIRED_INCLUDES)
+  unset(CMAKE_REQUIRED_LIBRARIES)
+endif()
+
+# Standard package handling
+include(FindPackageHandleStandardArgs)
+if(CMAKE_VERSION VERSION_GREATER 2.8.2)
+  find_package_handle_standard_args(METIS
+    REQUIRED_VARS METIS_LIBRARY METIS_INCLUDE_DIR METIS_TEST_RUNS
+    VERSION_VAR METIS_VERSION_STRING)
+else()
+  find_package_handle_standard_args(METIS
+    REQUIRED_VARS METIS_LIBRARY METIS_INCLUDE_DIR METIS_TEST_RUNS)
+endif()
+
+if(METIS_FOUND)
+  set(METIS_LIBRARIES ${METIS_LIBRARY})
+  set(METIS_INCLUDE_DIRS ${METIS_INCLUDE_DIR})
+endif()
+
+mark_as_advanced(METIS_INCLUDE_DIR METIS_LIBRARY)
\ No newline at end of file
diff --git a/cmake/modules/FindNANOFLANN.cmake b/cmake/modules/FindNANOFLANN.cmake
new file mode 100644
index 00000000..9982fee5
--- /dev/null
+++ b/cmake/modules/FindNANOFLANN.cmake
@@ -0,0 +1,41 @@
+# Define a CMake module to find NANOFLANN header using find_package
+
+# Usage: find_package(NANOFLANN [VERSION version] [REQUIRED] [QUIET])
+#
+# Searches for the NANOFLANN header file and sets the variable
+# `NANOFLANN_FOUND` to `TRUE` if the header file is found,
+# and sets the variable `NANOFLANN_INCLUDE_DIRS` to the include directories
+# containing the header file.
+#
+# Example usage:
+#   find_package(NANOFLANN REQUIRED)
+# Define user options
+
+if(NOT NANOFLANN_INCLUDE_DIR)
+  message(STATUS "NANOFLANN_INCLUDE_DIR not defined, searching for NANOFLANN header")  
+  find_path(NANOFLANN_INCLUDE_DIR nanoflann.hpp
+    HINTS "$ENV{NANOFLANN}/include" "$ENV{CONDA_PREFIX}/include" "$ENV{BUILD_PREFIX}/include"
+    PATH_SUFFIXES include
+    DOC "Directory where the NANOFLANN header files are located"
+  )
+endif()
+
+# Find NANOFLANN header
+find_path(NANOFLANN_INCLUDE_DIRS
+    NAMES nanoflann.hpp
+    PATH_SUFFIXES include
+)
+
+# Check if NANOFLANN header is found
+if(NANOFLANN_INCLUDE_DIR)
+    message(STATUS "NANOFLANN found")
+    set(NANOFLANN_FOUND TRUE)
+else()
+    set(NANOFLANN_FOUND FALSE)
+endif()
+
+# Standard package handling
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(NANOFLANN REQUIRED_VARS NANOFLANN_INCLUDE_DIR)
+
+mark_as_advanced(NANOFLANN_INCLUDE_DIR)
diff --git a/cmake/modules/FindPHMAP.cmake b/cmake/modules/FindPHMAP.cmake
new file mode 100644
index 00000000..90fdc23b
--- /dev/null
+++ b/cmake/modules/FindPHMAP.cmake
@@ -0,0 +1,41 @@
+# Define a CMake module to find PHMAP header using find_package
+
+# Usage: find_package(PHMAP [VERSION version] [REQUIRED] [QUIET])
+#
+# Searches for the PHMAP header file and sets the variable
+# `PHMAP_FOUND` to `TRUE` if the header file is found,
+# and sets the variable `PHMAP_INCLUDE_DIRS` to the include directories
+# containing the header file.
+#
+# Example usage:
+#   find_package(PHMAP REQUIRED)
+# Define user options
+
+if(NOT PHMAP_INCLUDE_DIR)
+  message(STATUS "PHMAP_INCLUDE_DIR not defined, searching for PHMAP header")  
+  find_path(PHMAP_INCLUDE_DIR parallel_hashmap/phmap.h
+    HINTS "$ENV{PHMAP}/include" "$ENV{CONDA_PREFIX}/include" "$ENV{BUILD_PREFIX}/include"
+    PATH_SUFFIXES include
+    DOC "Directory where the PHMAP header files are located"
+  )
+endif()
+
+# Find PHMAP header
+find_path(PHMAP_INCLUDE_DIRS
+    NAMES phmap.h
+    PATH_SUFFIXES include
+)
+
+# Check if PHMAP header is found
+if(PHMAP_INCLUDE_DIR)
+    message(STATUS "PHMAP found")
+    set(PHMAP_FOUND TRUE)
+else()
+    set(PHMAP_FOUND FALSE)
+endif()
+
+# Standard package handling
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(PHMAP REQUIRED_VARS PHMAP_INCLUDE_DIR)
+
+mark_as_advanced(PHMAP_INCLUDE_DIR)
diff --git a/cmake/modules/FindXBYAK.cmake b/cmake/modules/FindXBYAK.cmake
new file mode 100644
index 00000000..94a3708a
--- /dev/null
+++ b/cmake/modules/FindXBYAK.cmake
@@ -0,0 +1,41 @@
+# Define a CMake module to find XBYAK header using find_package
+
+# Usage: find_package(XBYAK [VERSION version] [REQUIRED] [QUIET])
+#
+# Searches for the XBYAK header file and sets the variable
+# `XBYAK_FOUND` to `TRUE` if the header file is found,
+# and sets the variable `XBYAK_INCLUDE_DIRS` to the include directories
+# containing the header file.
+#
+# Example usage:
+#   find_package(XBYAK REQUIRED)
+# Define user options
+
+if(NOT XBYAK_INCLUDE_DIR)
+  message(STATUS "XBYAK_INCLUDE_DIR not defined, searching for XBYAK header")  
+  find_path(XBYAK_INCLUDE_DIR xbyak/xbyak.h
+    HINTS $ENV{XBYAK}/include $ENV{CONDA_PREFIX}/include $ENV{BUILD_PREFIX}/include/
+    PATH_SUFFIXES include
+    DOC "Directory where the XBYAK header files are located"
+  )
+endif()
+
+# Find XBYAK header
+find_path(XBYAK_INCLUDE_DIRS
+    NAMES xbyak.h
+    PATH_SUFFIXES include
+)
+
+# Check if XBYAK header is found
+if(XBYAK_INCLUDE_DIR)
+    message(STATUS "XBYAK found")
+    set(XBYAK_FOUND TRUE)
+else()
+    set(XBYAK_FOUND FALSE)
+endif()
+
+# Standard package handling
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(XBYAK REQUIRED_VARS XBYAK_INCLUDE_DIR)
+
+mark_as_advanced(XBYAK_INCLUDE_DIR)
diff --git a/src/array/cuda/functor.cuh b/src/array/cuda/functor.cuh
index 0070120b..b8ff8652 100644
--- a/src/array/cuda/functor.cuh
+++ b/src/array/cuda/functor.cuh
@@ -9,6 +9,7 @@
 #include "./atomic.cuh"
 #include "./fp16.cuh"
 #include <cmath>
+#include <limits>
 
 namespace dgl {
 namespace aten {
diff --git a/src/graph/metis_partition.cc b/src/graph/metis_partition.cc
index cc695b95..07bed1db 100644
--- a/src/graph/metis_partition.cc
+++ b/src/graph/metis_partition.cc
@@ -45,10 +45,10 @@ IdArray MetisPartition(GraphPtr g, int k, NDArray vwgt_arr, bool obj_cut) {
 
   idx_t options[METIS_NOPTIONS];
   METIS_SetDefaultOptions(options);
-  options[METIS_OPTION_ONDISK] = 1;
+  // options[METIS_OPTION_ONDISK] = 1;
   options[METIS_OPTION_NITER] = 1;
-  options[METIS_OPTION_NIPARTS] = 1;
-  options[METIS_OPTION_DROPEDGES] = 1;
+  // options[METIS_OPTION_NIPARTS] = 1;
+  // options[METIS_OPTION_DROPEDGES] = 1;
 
   if (obj_cut) {
     options[METIS_OPTION_OBJTYPE] = METIS_OBJTYPE_CUT;
diff --git a/src/graph/transform/metis_partition_hetero.cc b/src/graph/transform/metis_partition_hetero.cc
index 4e4c7bd3..6ab086cf 100644
--- a/src/graph/transform/metis_partition_hetero.cc
+++ b/src/graph/transform/metis_partition_hetero.cc
@@ -55,10 +55,10 @@ IdArray MetisPartition(UnitGraphPtr g, int k, NDArray vwgt_arr,
 
   idx_t options[METIS_NOPTIONS];
   METIS_SetDefaultOptions(options);
-  options[METIS_OPTION_ONDISK] = 1;
+  // options[METIS_OPTION_ONDISK] = 1;
   options[METIS_OPTION_NITER] = 1;
-  options[METIS_OPTION_NIPARTS] = 1;
-  options[METIS_OPTION_DROPEDGES] = 1;
+  // options[METIS_OPTION_NIPARTS] = 1;
+  // options[METIS_OPTION_DROPEDGES] = 1;
 
   if (obj_cut) {
     options[METIS_OPTION_OBJTYPE] = METIS_OBJTYPE_CUT;
